@tool
extends CutoutContourAlgorithm
class_name CutoutContourMarchingSquares

## Clean implementation of the marching squares algorithm for contour extraction.
##
## The algorithm works by:
## 1. Dividing the image into a grid of cells
## 2. For each cell, checking which corners are "inside" (opaque)
## 3. Using a lookup table to determine where contour lines cross cell edges
## 4. Tracing complete contours by following edges from cell to cell

<<<<<<< HEAD
const DISPLAY_NAME := "Marching Squares"

# Edge Indices for marching squares
const EDGE_TOP    = 0
const EDGE_RIGHT  = 1
const EDGE_BOTTOM = 2
const EDGE_LEFT   = 3
=======
# Edge indices (which side of a cell)
enum Edge { TOP = 0, RIGHT = 1, BOTTOM = 2, LEFT = 3 }
>>>>>>> 560face3450c0d43b9d84936104235d6870bed4a

# Marching squares lookup table
# Index = binary representation of which corners are inside (bit 0=BL, 1=BR, 2=TR, 3=TL)
# Value = array of [entry_edge, exit_edge] pairs showing where contour crosses the cell
const LOOKUP_TABLE = [
	[],                    # 0000: no corners inside
	[[Edge.LEFT, Edge.BOTTOM]],              # 0001: bottom-left
	[[Edge.BOTTOM, Edge.RIGHT]],             # 0010: bottom-right
	[[Edge.LEFT, Edge.RIGHT]],               # 0011: bottom edge
	[[Edge.TOP, Edge.RIGHT]],                # 0100: top-right
	[[Edge.LEFT, Edge.BOTTOM], [Edge.TOP, Edge.RIGHT]],  # 0101: diagonal (ambiguous)
	[[Edge.BOTTOM, Edge.TOP]],               # 0110: right edge
	[[Edge.LEFT, Edge.TOP]],                 # 0111: top-right filled
	[[Edge.LEFT, Edge.TOP]],                 # 1000: top-left
	[[Edge.BOTTOM, Edge.TOP]],               # 1001: left edge
	[[Edge.LEFT, Edge.RIGHT], [Edge.BOTTOM, Edge.TOP]],  # 1010: diagonal (ambiguous)
	[[Edge.BOTTOM, Edge.RIGHT]],             # 1011: bottom-left filled
	[[Edge.LEFT, Edge.RIGHT]],               # 1100: top edge
	[[Edge.BOTTOM, Edge.RIGHT]],             # 1101: top-left filled
	[[Edge.LEFT, Edge.BOTTOM]],              # 1110: top-right filled
	[]                     # 1111: all corners inside
]


func _calculate_boundary(image: Image) -> Array[PackedVector2Array]:
	# Convert image to bitmap for easy alpha testing
	var converted_image := image.duplicate()
	if converted_image.is_compressed():
		converted_image.decompress()
	converted_image.convert(Image.FORMAT_LA8)

	var bitmap := BitMap.new()
	bitmap.create_from_image_alpha(converted_image, alpha_threshold)

	return _extract_contours(bitmap)


## Main marching squares algorithm
func _extract_contours(bitmap: BitMap) -> Array[PackedVector2Array]:
	var size := bitmap.get_size()
	var contours: Array[PackedVector2Array] = []

	if size.x <= 0 or size.y <= 0:
		return contours

<<<<<<< HEAD
	# Create visited bitmap to track processed cells
	# Note: This persists across all contours to prevent re-processing shared edges
	var visited := {}  # Use dictionary with integer keys for speed
=======
	# Track which cells have been visited to avoid retracing contours
	var visited := {}
>>>>>>> 560face3450c0d43b9d84936104235d6870bed4a

	# Scan through each cell in the grid
	for cell_y in range(size.y):
		for cell_x in range(size.x):
			# Skip if already visited
			var key := _make_key(cell_x, cell_y)
			if visited.has(key):
				continue

			# Get the configuration for this cell
			var config := _get_cell_config(bitmap, cell_x, cell_y, size)

			# Skip empty or full cells (no contour edges)
			if config == 0 or config == 15:
				continue

<<<<<<< HEAD
	# Then scan interior with adaptive step size to catch thin features
	for y in range(1, size.y - 1):
		# Use adaptive scanning: step=2 normally, but step=1 near detected edges
		var x := 1
		while x < size.x - 1:
			if bitmap.get_bit(x, y) and _is_edge_pixel_fast(bitmap, x, y, size):
				edge_points.append(Vector2i(x, y))
				# Switch to step=1 for next few pixels to catch thin features
				x += 1
			else:
				# No edge here, can skip ahead
				x += 2

	# Process each edge point
	for point in edge_points:
		# Bounds check: Can't create cell from pixels at position 0
		if point.x == 0 or point.y == 0:
			continue

		var cell_x: int = point.x - 1
		var cell_y: int = point.y - 1

		# Check if this cell has already been processed
		var cell_key := _pack_key(cell_x, cell_y)
		if visited.has(cell_key):
			continue

		# Trace the contour from this cell
		var contour := _trace_contour_optimized(bitmap, cell_x, cell_y, size, visited)
		if contour.size() >= 3:  # Minimum valid closed contour (triangle)
			# Ensure clockwise winding order (CW = solid, CCW = hole)
			_normalize_winding_order(contour)
			contours.append(contour)
=======
			# Check if this cell has a contour edge
			var edges = LOOKUP_TABLE[config]
			if edges.is_empty():
				continue

			# Found a contour start point - trace it
			var contour := _trace_contour(bitmap, cell_x, cell_y, size, visited)

			# Only keep contours with at least 3 points
			if contour.size() >= 3:
				contours.append(contour)
>>>>>>> 560face3450c0d43b9d84936104235d6870bed4a

	return contours


<<<<<<< HEAD
## Normalize contour to clockwise winding order using shoelace formula
static func _normalize_winding_order(contour: PackedVector2Array) -> void:
	if contour.size() < 3:
		return

	# Calculate signed area using shoelace formula
	# Positive area = counter-clockwise, Negative = clockwise
	var signed_area := 0.0
	var n := contour.size()
	for i in range(n):
		var j := (i + 1) % n
		signed_area += contour[i].x * contour[j].y
		signed_area -= contour[j].x * contour[i].y

	# If counter-clockwise (positive area), reverse to make clockwise
	if signed_area > 0:
		contour.reverse()


## Fast edge pixel check (inline for performance)
static func _is_edge_pixel_fast(bitmap: BitMap, x: int, y: int, size: Vector2i) -> bool:
	# Check 4-neighbors in one pass
	return (x > 0 and not bitmap.get_bit(x - 1, y)) or \
		   (x < size.x - 1 and not bitmap.get_bit(x + 1, y)) or \
		   (y > 0 and not bitmap.get_bit(x, y - 1)) or \
		   (y < size.y - 1 and not bitmap.get_bit(x, y + 1))
=======
## Determine which corners of a cell are inside
## Returns a 4-bit configuration: bit 0=bottom-left, 1=bottom-right, 2=top-right, 3=top-left
func _get_cell_config(bitmap: BitMap, cell_x: int, cell_y: int, size: Vector2i) -> int:
	var config := 0

	# Bottom-left corner (x, y+1)
	if cell_y + 1 < size.y and cell_x < size.x:
		if bitmap.get_bit(cell_x, cell_y + 1):
			config |= 1

	# Bottom-right corner (x+1, y+1)
	if cell_y + 1 < size.y and cell_x + 1 < size.x:
		if bitmap.get_bit(cell_x + 1, cell_y + 1):
			config |= 2

	# Top-right corner (x+1, y)
	if cell_y < size.y and cell_x + 1 < size.x:
		if bitmap.get_bit(cell_x + 1, cell_y):
			config |= 4

	# Top-left corner (x, y)
	if cell_y < size.y and cell_x < size.x:
		if bitmap.get_bit(cell_x, cell_y):
			config |= 8

	return config
>>>>>>> 560face3450c0d43b9d84936104235d6870bed4a


## Trace a complete contour starting from a given cell
func _trace_contour(bitmap: BitMap, start_x: int, start_y: int, size: Vector2i, visited: Dictionary) -> PackedVector2Array:
	var contour := PackedVector2Array()
	var current_x := start_x
	var current_y := start_y

	var max_steps := size.x * size.y * 4  # Safety limit
	var steps := 0

	# For the first cell, we need to determine an initial entry edge
	# We'll use -1 to indicate we're starting (no entry edge yet)
	var entry_edge := -1

	while steps < max_steps:
		steps += 1

		# Mark current cell as visited
		var key := _make_key(current_x, current_y)
		visited[key] = true

		# Get the configuration for current cell
		var config := _get_cell_config(bitmap, current_x, current_y, size)

		# Skip empty or full cells
		if config == 0 or config == 15:
			break

		# Determine the correct edge pair to use
		var edge_pair: Array
		if config == 5 or config == 10:
			# Handle ambiguous diagonal cases
			edge_pair = _resolve_ambiguous_case(bitmap, current_x, current_y, size, config, entry_edge)
		else:
			# For non-ambiguous cases, find the edge pair that matches our entry
			var edges = LOOKUP_TABLE[config]
			if edges.is_empty():
				break

			if entry_edge == -1:
				# First cell - use the first edge pair
				edge_pair = edges[0]
			else:
				# Find the edge pair that matches our entry
				edge_pair = []
				for pair in edges:
					if pair[0] == entry_edge or pair[1] == entry_edge:
						edge_pair = pair
						break

				# If no match found, something went wrong
				if edge_pair.is_empty():
					break

		if edge_pair.is_empty() or edge_pair.size() < 2:
			break

		# Determine entry and exit edges
		var cell_entry: int
		var cell_exit: int

		if entry_edge == -1:
			# First cell - use the pair as-is
			cell_entry = edge_pair[0]
			cell_exit = edge_pair[1]
		else:
			# Subsequent cells - ensure entry matches where we came from
			if edge_pair[0] == entry_edge:
				cell_entry = edge_pair[0]
				cell_exit = edge_pair[1]
			else:
				cell_entry = edge_pair[1]
				cell_exit = edge_pair[0]

		# Add contour points
		var entry_point := _get_edge_midpoint(current_x, current_y, cell_entry)
		var exit_point := _get_edge_midpoint(current_x, current_y, cell_exit)

		if contour.is_empty():
			# First cell - add both entry and exit points
			contour.append(entry_point)
			contour.append(exit_point)
		else:
			# Subsequent cells - only add the exit point
			contour.append(exit_point)

		# Move to the next cell based on which edge we exited from
		var next_x := current_x
		var next_y := current_y

		match cell_exit:
			Edge.TOP:
				next_y -= 1
			Edge.RIGHT:
				next_x += 1
			Edge.BOTTOM:
				next_y += 1
			Edge.LEFT:
				next_x -= 1
			_:
				break

		# Check if we've completed the loop
		if next_x == start_x and next_y == start_y:
			break

		# Check if we've gone out of bounds
		if next_x < 0 or next_x >= size.x or next_y < 0 or next_y >= size.y:
			break

		# Update position and entry edge for next iteration
		current_x = next_x
		current_y = next_y
		entry_edge = _get_opposite_edge(cell_exit)

	# Clean up the contour before returning
	return _cleanup_contour(contour)


## Get the midpoint of a cell edge
func _get_edge_midpoint(cell_x: int, cell_y: int, edge: int) -> Vector2:
	match edge:
		Edge.TOP:
			return Vector2(cell_x + 0.5, cell_y)
		Edge.RIGHT:
			return Vector2(cell_x + 1.0, cell_y + 0.5)
		Edge.BOTTOM:
			return Vector2(cell_x + 0.5, cell_y + 1.0)
		Edge.LEFT:
			return Vector2(cell_x, cell_y + 0.5)
		_:
			return Vector2(cell_x + 0.5, cell_y + 0.5)


## Create a unique key for a cell position
func _make_key(x: int, y: int) -> int:
	return (x << 16) | (y & 0xFFFF)


## Find the correct exit edge given an entry edge and cell configuration
## This ensures we follow the correct contour path through the cell
func _find_exit_edge(config: int, entry_edge: int) -> int:
	var edges = LOOKUP_TABLE[config]
	if edges.is_empty():
		return -1

	# For non-ambiguous cases, find the edge pair where our entry matches
	for edge_pair in edges:
		var pair_entry = edge_pair[0]
		var pair_exit = edge_pair[1]

		# Check if this pair matches our entry (accounting for both directions)
		if pair_entry == entry_edge:
			return pair_exit
		elif pair_exit == entry_edge:
			return pair_entry

	# If no match found (shouldn't happen in valid contours), use first pair's exit
	return edges[0][1]


## Get the opposite edge (the edge on the neighboring cell we'll enter from)
func _get_opposite_edge(edge: int) -> int:
	match edge:
		Edge.TOP:
			return Edge.BOTTOM
		Edge.BOTTOM:
			return Edge.TOP
		Edge.LEFT:
			return Edge.RIGHT
		Edge.RIGHT:
			return Edge.LEFT
		_:
			return -1


## Resolve ambiguous diagonal cases (configs 5 and 10) by checking neighboring pixels
## Returns the correct edge pair to use based on the entry edge and surrounding context
func _resolve_ambiguous_case(bitmap: BitMap, cell_x: int, cell_y: int, size: Vector2i, config: int, entry_edge: int) -> Array:
	# Config 5: bottom-left and top-right corners filled (0101)
	# Config 10: bottom-right and top-left corners filled (1010)

	var edges = LOOKUP_TABLE[config]
	if edges.size() != 2:
		# Not an ambiguous case, return first edge pair
		return edges[0] if edges.size() > 0 else []

	# For ambiguous cases, we need to determine which of the two contour segments to follow
	# We do this by checking which edge pair matches our entry edge
	var first_pair = edges[0]
	var second_pair = edges[1]

	# Check if entry edge matches first pair
	if entry_edge == first_pair[0] or entry_edge == first_pair[1]:
		return first_pair

	# Check if entry edge matches second pair
	if entry_edge == second_pair[0] or entry_edge == second_pair[1]:
		return second_pair

	# If neither matches (first cell in contour), use a heuristic
	# For config 5 (BL+TR), prefer the pair that creates a continuous contour
	# For config 10 (BR+TL), same logic
	# Default to first pair as a fallback
	return first_pair


## Clean up a contour to ensure it's properly closed
## Removes duplicate points and validates the polygon
func _cleanup_contour(contour: PackedVector2Array) -> PackedVector2Array:
	if contour.size() < 3:
		return contour

	var cleaned := PackedVector2Array()
	var epsilon := 0.001  # Threshold for considering points equal

	# Add all unique points
	for i in range(contour.size()):
		var point = contour[i]

		# Check if this point is too close to the last added point
		if cleaned.is_empty() or cleaned[cleaned.size() - 1].distance_squared_to(point) > epsilon:
			cleaned.append(point)

	# Check if the last point is too close to the first point (closing the loop)
	if cleaned.size() > 2:
		if cleaned[cleaned.size() - 1].distance_squared_to(cleaned[0]) < epsilon:
			# Remove the duplicate closing point
			cleaned.remove_at(cleaned.size() - 1)

	return cleaned
